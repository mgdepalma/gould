#!/bin/sh
##
# hwsetup - automatic hardware configuration tool
#
# 2020-02-02 Generations Linux <info@softcraft.org>
#
LICENSE="GNU Public License (GPL) version 3"

PROGRAM=${0##*/}
VERSION="1.2"

# print message and exit
abend()
{
  echo "${PROGRAM}: $*"
  exit 1
}

# show program usage
usage()
{
  cat << EOF

usage: $PROGRAM [-v] [-h] [-c <DIR>] [-l <FILE>] [-p] [-u]

 options
  -v       show program version and exit
  -h       show usage and exit; what you reading
  -c <DIR> use DIR instead of $SYSCONFIG/
  -l <LOG> use LOG file for $PROGRAM produced messages
  -p	   print progress bar, implies verbose mode
  -u       only update $SYSCONFIG/hardware

 ${PROGRAM} is provided under the terms and conditions of the
 ${LICENSE}.

EOF
}

# show program version
version()
{
cat << EOF

 $PROGRAM version $VERSION [$LICENSE]

EOF
}

# PCMCIA check/setup
# (This needs to be done before other modules are loaded)
cardbus()
{
  PCMCIA=no
  echo "PCMCIA=no" > $SYSCONFIG/pcmcia

  PCIC=yenta_socket
  #PCIC="yenta_socket i82365 tcic"

  if modprobe $PCIC >/dev/null 2>&1; then
    if grep -q pcmcia /proc/devices; then
      if cardmgr 2>/dev/null; then
        echo "PCMCIA=yes" > $SYSCONFIG/pcmcia
        echo "PCIC=$PCIC" >>$SYSCONFIG/pcmcia
        touch /var/lock/subsys/pcmcia
        PCMCIA=yes
      fi
    else
      modprobe -r $PCIC
    fi
  fi
}

# do modprobe with a time out
kmodload()
{
  modprobe $1 & pid=$!
  # set timeout alarm
  trap true ALRM
  ppid=$$

  (sleep 5 && kill -ALRM $ppid) & alarm=$!
  wait $pid
  status=$?

  if [ $status -gt 128 ]; then
    # timed out (alarm)
    kill $pid
  else
    status=0
    # cancel timeout alarm
    disarm
  fi
  return $status
}

# scan for network devices
networking()
{
  netcard="hwinfo --netcard"
  MACS=$($netcard --short | tail -n+2 | wc -l)
  showprogress "netcard count: $MACS"
  [ -n "$MACS" ] || return 1

  # location of network devices and count
  space=/sys/class/net
  count=0

  broadcom=b43
  # hard to detect b43, hwinfo reports "ssb", use wl.ko (hybrid) if available
  #[ -e /lib/modules/$(uname -r)/contrib/wireless/wl.ko ] && broadcom=wl

  while [ $count -lt $MACS ]; do
    pos=$(($count + 2))
    count=$(($count + 1))

    seen=$($netcard --short | tail -n+$pos | head -1)
    name=$(echo $seen | awk '{print $1}')

    # continue to next item, if already in $INTERFACES
    echo $INTERFACES | grep -q "$name:" && continue 

    row=$(($pos - 1))
    ko=$($netcard | grep "$match" | tail -n+$row | head -1 | awk '{print $3}')
    showprogress "[$count] driver: $ko"
    [ "$ko" = "ssb" ] && ko=$broadcom

    if [ ! -e $space/$name ]; then
      # load driver to see the interface
      kmodload $ko >/dev/null 2>&1

      if [ $? -ne 0 ]; then
        showprogress -w "[$count] device: -"
        #kmodload -r $ko >/dev/null 2>&1
        #kmodload $ko >/dev/null 2>&1
        #[ $? -eq 0 ] || continue
        continue
      fi
      seen=$($netcard --short | tail -n+$pos | head -1)
      name=$(echo $seen | awk '{print $1}')
    fi

    if [ -e $space/$name ]; then
      showprogress "[$count] device: $name"
      INTERFACES="${INTERFACES:+"$INTERFACES "}$name:$ko"
    fi
  done

  # cancel timeout alarm
  disarm
}

# cancel timeout alarm
disarm()
{
  [ -n "$alarm" ] && {\
    kill -1 $alarm 2>/dev/null && kill $alarm
    alarm=
  }
  trap graceland ALRM
}

# probe hardware on the system
discover()
{
  #(legacy) APM Bios stuff
  #if modprobe apm power_off=1 >/dev/null 2>&1; then
  #  APM="APM Bios found."
  #fi 

  # processor, memory, graphics, sound and storage
  CPU=$(echo $(hwinfo --cpu --short | tail -n+2 | head -1))
  showprogress "CPU"

  MEMORY=$(echo $(grep ^MemTotal /proc/meminfo|cut -d: -f2-))
  showprogress "memory"

  GFX=$(echo $(hwinfo --gfx --short | tail -n+2 | head -1))
  showprogress "graphics"

  SOUND=$(echo $(hwinfo --sound --short | tail -n+2))
  showprogress "sound"

  STORAGE=$(echo $(hwinfo --storage --short | tail -n+2))
  showprogress "storage"

  # storage devices (only the first one)
  DESC=$(hwinfo --disk --short | tail -n+2 | head -1)
  DISC=$(echo $DESC | awk '{print $1}')

  DESC=$(echo $DESC | sed -e "s,$DISC,,")
  SIZE=$(fdisk -l $DISC | tail -n+2 | head -1 | awk '{print $3 $4}')
  showprogress "$DISC: $SIZE"

  # optical media (only the first one)
  CDROM=$(echo $(hwinfo --cdrom --short | tail -n+2 | head -1))
  showprogress "CDROM/DVD"

  # network discovery
  networking

  # PCMCIA cardbus
  showprogress "cardbus"
  cardbus
}

# generate hardware summary
hardinfo()
{
  # write out hardware summary file
  HARDWARE=$SYSCONFIG/hardware
  [ -e $HARDWARE ] && mv $HARDWARE $HARDWARE.old
  cat << EOF > $HARDWARE
##
# hardware summary description generated by $PROGRAM
# $(date -u +'%F %X %Z')
#
CPU="$CPU"
MEMORY="$MEMORY"
GRAPHICS="$GFX"
SOUND="$SOUND"
STORAGE="$STORAGE"
DISC="${DISC} $SIZE $DESC"
CDROM="$CDROM"
INTERFACES="$INTERFACES"
PCMCIA="$PCMCIA"

EOF
  # if only $UPDATE we are done, otherwise generate configurations files
  [ -n "$UPDATE" ] || writefiles
}

# write the individual configuration files
writefiles()
{
  if [ -n "$SOUND" ]; then
    ko=$(hwinfo --sound | grep "$match" | head -1 | awk '{print $3}')
    cat << EOF > $SYSCONFIG/sound
DESC="$SOUND"
DRIVER="$ko"
EOF
  fi

  # create symlink for optical drive
  if [ -n "$CDROM" ]; then
    DEVICE=$(echo $CDROM | awk '{print $1}')
    name=$(echo $DEVICE | cut -d/ -f3 | cut -d\( -f1)
    showprogress "/dev/cdrom -> $name"
    space=/sys/block/$name

    if [ -e $space ]; then
      curdir=${PWD}
      cd /dev

      if [ -e $space/ro ]; then
        if [ $(cat $space/ro) -eq 0 ]; then
          [ -e cdrecorder ] || ln -s $name cdrecorder
        fi
      fi
      [ -e cdrom ] || ln -s $name cdrom
      cd $curdir
    fi
  fi

  # network devices configuration folder
  SYSNETWORK=${SYSNETWORK:-/etc/network}
  [ -d $SYSNETWORK ] || mkdir -p $SYSNETWORK

  # iterate network devices list
  for seen in $INTERFACES; do
    IT=$(echo $seen | cut -d: -f1)
    ko=$(echo $seen | cut -d: -f2)
    DESC=$(echo $(hwinfo --netcard --short | grep $IT | sed -e "s,$IT,,"))
    cat << EOF > $SYSNETWORK/ifcfg-$IT
DESC="$DESC"
DRIVER="$ko"
EOF
    showprogress "$SYSNETWORK/ifcfg-$IT"
  done

  # iterate added modules list
  for DRIVER in $MODULES; do
    echo $DRIVER >> $SYSCONFIG/modules
  done
}

# show progress [$service] // silent, unless $VERBOSE
showprogress()
{
  local color

  case "$1" in
    -e) color=${RED}; level=err; shift ;;
    -w) color=${YELLOW}; level=warn; shift ;;
     *) color=${GREEN}; level=info
  esac

  [ -n "$LOGFILE" ] && echo "$(date -u +'%F %X %Z') $level: $*" >> $LOGFILE
  [ -n "$VERBOSE" ] && echo -n "${INVERT}${color} ${RESET}"
}

# generic signal handler
graceful()
{
  hardinfo
  [ -n "$VERBOSE" ] && echo "${RESET} Timeout."
  exit 1
}

# ALRM signal handler
graceland()
{
  hardinfo
  [ -n "$VERBOSE" ] && echo "${RESET} Alarm."
  exit 1
}

##
# main program logic
CSI="["

RED="${CSI}1;31m"
GREEN="${CSI}1;32m"
YELLOW="${CSI}1;33m"
NORMAL="${CSI}0;39m"
INVERT="${CSI}7m"
RESET="${CSI}m"

# process command line options
SYSCONFIG=${SYSCONFIG:-/etc/sysconfig}
OPTERR=0

while getopts "hvc:l:pu" flag
do
  case $flag in
    h) usage; exit 0 ;;
    v) version; exit 0 ;;
    c) SYSCONFIG=$OPTARG ;;
    l) LOGFILE=$OPTARG ;;
    p) VERBOSE=yes ;;
    u) UPDATE=yes ;;
    *) abend "unrecognized option (use: -h for help)" ;;
  esac
done

[ -d $SYSCONFIG ] || abend "$SYSCONFIG: No such file or directory"
[ -n "$LOGFILE" ] && [ -f $LOGFILE ] && rm $LOGFILE

export SYSCONFIG=$SYSCONFIG

# Gracefully handle interrupt signals.
trap graceful 1 2 3 15
[ -n "$VERBOSE" ] && echo -n "Autoconfiguring devices... "

match="Driver Status:"
discover
hardinfo
usbscan

# We are done, restore interrupt signals.
[ -n "$VERBOSE" ] && echo " Done."
trap 1 2 3 15
##
